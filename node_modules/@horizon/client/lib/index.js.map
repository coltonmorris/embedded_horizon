{"version":3,"sources":["../src/index.js"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["import { Observable } from 'rxjs/Observable'\nimport 'rxjs/add/observable/of'\nimport 'rxjs/add/observable/from'\nimport 'rxjs/add/operator/catch'\nimport 'rxjs/add/operator/concatMap'\nimport 'rxjs/add/operator/map'\nimport 'rxjs/add/operator/filter'\n\n// Extra operators not used, but useful to Horizon end-users\nimport 'rxjs/add/operator/defaultIfEmpty'\n\nconst { Collection, UserDataTerm } = require('./ast.js')\nconst HorizonSocket = require('./socket.js')\nconst { log, logError, enableLogging } = require('./logging.js')\nconst { authEndpoint, TokenStorage, clearAuthTokens } = require('./auth')\n\nconst defaultHost = typeof window !== 'undefined' && window.location &&\n        `${window.location.host}` || 'localhost:8181'\nconst defaultSecure = typeof window !== 'undefined' && window.location &&\n        window.location.protocol === 'https:' || false\n\nfunction Horizon({\n  host = defaultHost,\n  secure = defaultSecure,\n  path = 'horizon',\n  lazyWrites = false,\n  authType = 'unauthenticated',\n} = {}) {\n  // If we're in a redirection from OAuth, store the auth token for\n  // this user in localStorage.\n\n  const tokenStorage = new TokenStorage({ authType, path })\n  tokenStorage.setAuthFromQueryParams()\n\n  const socket = new HorizonSocket(\n    host, secure, path, ::tokenStorage.handshake)\n\n  // Store whatever token we get back from the server when we get a\n  // handshake response\n  socket.handshake.subscribe({\n    next(handshake) {\n      if (authType !== 'unauthenticated') {\n        tokenStorage.set(handshake.token)\n      }\n    },\n    error(err) {\n      if (/JsonWebTokenError|TokenExpiredError/.test(err.message)) {\n        console.error('Horizon: clearing token storage since auth failed')\n        tokenStorage.remove()\n      }\n    },\n  })\n\n  // This is the object returned by the Horizon function. It's a\n  // function so we can construct a collection simply by calling it\n  // like horizon('my_collection')\n  function horizon(name) {\n    return new Collection(sendRequest, name, lazyWrites)\n  }\n\n  horizon.currentUser = () =>\n    new UserDataTerm(horizon, socket.handshake, socket)\n\n  horizon.disconnect = () => {\n    socket.complete()\n  }\n\n  // Dummy subscription to force it to connect to the\n  // server. Optionally provide an error handling function if the\n  // socket experiences an error.\n  // Note: Users of the Observable interface shouldn't need this\n  horizon.connect = (\n    onError = err => { console.error(`Received an error: ${err}`) }\n  ) => {\n    socket.subscribe(\n      () => {},\n      onError\n    )\n  }\n\n  // Either subscribe to status updates, or return an observable with\n  // the current status and all subsequent status changes.\n  horizon.status = subscribeOrObservable(socket.status)\n\n  // Convenience method for finding out when disconnected\n  horizon.onDisconnected = subscribeOrObservable(\n    socket.status.filter(x => x.type === 'disconnected'))\n\n  // Convenience method for finding out when ready\n  horizon.onReady = subscribeOrObservable(\n    socket.status.filter(x => x.type === 'ready'))\n\n  // Convenience method for finding out when an error occurs\n  horizon.onSocketError = subscribeOrObservable(\n    socket.status.filter(x => x.type === 'error'))\n\n  horizon.utensils = {\n    sendRequest,\n    tokenStorage,\n    handshake: socket.handshake,\n  }\n  Object.freeze(horizon.utensils)\n\n  horizon._authMethods = null\n  horizon._horizonPath = path\n  horizon.authEndpoint = authEndpoint\n  horizon.hasAuthToken = ::tokenStorage.hasAuthToken\n\n  return horizon\n\n  // Sends a horizon protocol request to the server, and pulls the data\n  // portion of the response out.\n  function sendRequest(type, options) {\n    // Both remove and removeAll use the type 'remove' in the protocol\n    const normalizedType = type === 'removeAll' ? 'remove' : type\n    return socket\n      .makeRequest({ type: normalizedType, options }) // send the raw request\n      .concatMap(resp => {\n        // unroll arrays being returned\n        if (resp.data) {\n          return Observable.from(resp.data)\n        } else {\n          // Still need to emit a document even if we have no new data\n          return Observable.from([ { state: resp.state, type: resp.type } ])\n        }\n      })\n      .catch(e => Observable.create(subscriber => {\n        subscriber.error(e)\n      })) // on error, strip error message\n  }\n}\n\nfunction subscribeOrObservable(observable) {\n  return (...args) => {\n    if (args.length > 0) {\n      return observable.subscribe(...args)\n    } else {\n      return observable\n    }\n  }\n}\n\nHorizon.log = log\nHorizon.logError = logError\nHorizon.enableLogging = enableLogging\nHorizon.Socket = HorizonSocket\nHorizon.clearAuthTokens = clearAuthTokens\n\nmodule.exports = Horizon\n"]}