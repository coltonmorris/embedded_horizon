{"version":3,"sources":["../src/socket.js"],"names":[],"mappings":"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","file":"socket.js","sourcesContent":["import { AsyncSubject } from 'rxjs/AsyncSubject'\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject'\nimport { Subject } from 'rxjs/Subject'\nimport { Observable } from 'rxjs/Observable'\nimport 'rxjs/add/observable/merge'\nimport 'rxjs/add/operator/filter'\nimport 'rxjs/add/operator/share'\n\nimport { serialize, deserialize } from './serialization.js'\nimport { log } from './logging.js'\nimport socket from 'engine.io-client'\n\nlet transports\n\nif (typeof window === 'undefined') {\n  transports = [ 'websocket' ]\n}\n\nconst PROTOCOL_VERSION = 'rethinkdb-horizon-v0'\n\n// Before connecting the first time\nconst STATUS_UNCONNECTED = { type: 'unconnected' }\n// After the websocket is opened and handshake is completed\nconst STATUS_READY = { type: 'ready' }\n// After unconnected, maybe before or after connected. Any socket level error\nconst STATUS_ERROR = { type: 'error' }\n// Occurs when the socket closes\nconst STATUS_DISCONNECTED = { type: 'disconnected' }\n\nclass ProtocolError extends Error {\n  constructor(msg, errorCode) {\n    super(msg)\n    this.errorCode = errorCode\n  }\n  toString() {\n    return `${this.message} (Code: ${this.errorCode})`\n  }\n}\n\n// Wraps native websockets with a Subject, which is both an Subscriber\n// and an Observable (it is bi-directional after all!). This\n// implementation is adapted from Rx.DOM.fromWebSocket and\n// RxSocketSubject by Ben Lesh, but it also deals with some simple\n// protocol level things like serializing from/to JSON, routing\n// request_ids, looking at the `state` field to decide when an\n// observable is closed.\nclass HorizonSocket extends Subject {\n  constructor(host, secure, path, handshaker) {\n    const hostString = `ws${secure ? 's' : ''}://${host}`\n    const msgBuffer = []\n    let ws, handshakeDisp\n    // Handshake is an asyncsubject because we want it to always cache\n    // the last value it received, like a promise\n    const handshake = new AsyncSubject()\n    const statusSubject = new BehaviorSubject(STATUS_UNCONNECTED)\n\n    const isOpen = () => Boolean(ws) && ws.readyState === 'open'\n\n    // Serializes to a string before sending\n    function wsSend(msg) {\n      const stringMsg = JSON.stringify(serialize(msg))\n\n      ws.send(stringMsg)\n    }\n\n    // This is the observable part of the Subject. It forwards events\n    // from the underlying websocket\n    const socketObservable = Observable.create(subscriber => {\n      ws = socket(hostString, {\n        protocol: PROTOCOL_VERSION,\n        path: `/${path}`,\n        transports\n      })\n\n      ws.on('error', () => {\n        // If the websocket experiences the error, we forward it through\n        // to the observable. Unfortunately, the event we receive in\n        // this callback doesn't tell us much of anything, so there's no\n        // reason to forward it on and we just send a generic error.\n        statusSubject.next(STATUS_ERROR)\n        const errMsg = `Websocket ${hostString} experienced an error`\n        subscriber.error(new Error(errMsg))\n      })\n\n      ws.on('open', () => {\n        ws.on('message', data => {\n          const deserialized = deserialize(JSON.parse(data))\n          log('Received', deserialized)\n          subscriber.next(deserialized)\n        })\n\n        ws.on('close', e => {\n          // This will happen if the socket is closed by the server If\n          // .close is called from the client (see closeSocket), this\n          // listener will be removed\n          statusSubject.next(STATUS_DISCONNECTED)\n          if (e !== 'forced close') {\n            subscriber.error(\n              new Error(`Socket closed unexpectedly with code: ${e}`)\n            )\n          } else {\n            subscriber.complete()\n          }\n        })\n\n        // Send the handshake\n        handshakeDisp = this.makeRequest(handshaker()).subscribe(\n          x => {\n            handshake.next(x)\n            handshake.complete()\n            statusSubject.next(STATUS_READY)\n          },\n          err => handshake.error(err),\n          () => handshake.complete()\n        )\n        // Send any messages that have been buffered\n        while (msgBuffer.length > 0) {\n          const msg = msgBuffer.shift()\n          log('Sending buffered:', msg)\n          wsSend(msg)\n        }\n      })\n      return () => {\n        if (handshakeDisp) {\n          handshakeDisp.unsubscribe()\n        }\n        // This is the \"unsubscribe\" method on the final Subject\n        closeSocket(1000, '')\n      }\n    }).share() // This makes it a \"hot\" observable, and refCounts it\n    // Note possible edge cases: the `share` operator is equivalent to\n    // .multicast(() => new Subject()).refCount() // RxJS 5\n    // .multicast(new Subject()).refCount() // RxJS 4\n\n    // This is the Subscriber part of the Subject. How we can send stuff\n    // over the websocket\n    const socketSubscriber = {\n      next(messageToSend) {\n        // When next is called on this subscriber\n        // Note: If we aren't ready, the message is silently dropped\n        if (isOpen()) {\n          log('Sending', messageToSend)\n          wsSend(messageToSend) // wsSend serializes to a string\n        } else {\n          log('Buffering', messageToSend)\n          msgBuffer.push(messageToSend)\n        }\n      },\n      error(error) {\n        // The subscriber is receiving an error. Better close the\n        // websocket with an error\n        if (!error.code) {\n          throw new Error('no code specified. Be sure to pass ' +\n                          '{ code: ###, reason: \"\" } to error()')\n        }\n        closeSocket(error.code, error.reason)\n      },\n      complete() {\n        // complete for the subscriber here is equivalent to \"close\n        // this socket successfully (which is what code 1000 is)\"\n        closeSocket(1000, '')\n      },\n    }\n\n    function closeSocket(code, reason) {\n      statusSubject.next(STATUS_DISCONNECTED)\n      if (!code) {\n        ws.close() // successful close\n      } else {\n        ws.close(code, reason)\n      }\n    }\n\n    super(socketSubscriber, socketObservable)\n\n    // Subscriptions will be the observable containing all\n    // queries/writes/changefeed requests. Specifically, the documents\n    // that initiate them, each one with a different request_id\n    const subscriptions = new Subject()\n    // Unsubscriptions is similar, only it holds only requests to\n    // close a particular request_id on the server. Currently we only\n    // need these for changefeeds.\n    const unsubscriptions = new Subject()\n    const outgoing = Observable.merge(subscriptions, unsubscriptions)\n    // How many requests are outstanding\n    let activeRequests = 0\n    // Monotonically increasing counter for request_ids\n    let requestCounter = 0\n    // Unsubscriber for subscriptions/unsubscriptions\n    let subDisp = null\n    // Now that super has been called, we can add attributes to this\n    this.handshake = handshake\n    // Lets external users keep track of the current websocket status\n    // without causing it to connect\n    this.status = statusSubject\n\n    const incrementActive = () => {\n      if (++activeRequests === 1) {\n        // We subscribe the socket itself to the subscription and\n        // unsubscription requests. Since the socket is both an\n        // observable and an subscriber. Here it's acting as an subscriber,\n        // watching our requests.\n        subDisp = outgoing.subscribe(this)\n      }\n    }\n\n    // Decrement the number of active requests on the socket, and\n    // close the socket if we're the last request\n    const decrementActive = () => {\n      if (--activeRequests === 0) {\n        subDisp.unsubscribe()\n      }\n    }\n\n    // This is used externally to send requests to the server\n    this.makeRequest = rawRequest => Observable.create(reqSubscriber => {\n      // Get a new request id\n      const request_id = requestCounter++\n      // Add the request id to the request and the unsubscribe request\n      // if there is one\n      rawRequest.request_id = request_id\n      const unsubscribeRequest = { request_id, type: 'end_subscription' }\n      // First, increment activeRequests and decide if we need to\n      // connect to the socket\n      incrementActive()\n\n      // Now send the request to the server\n      subscriptions.next(rawRequest)\n\n      // Create an observable from the socket that filters by request_id\n      const unsubscribeFilter = this\n            .filter(x => x.request_id === request_id)\n            .subscribe(\n              resp => {\n                // Need to faithfully end the stream if there is an error\n                if (resp.error !== undefined) {\n                  reqSubscriber.error(\n                    new ProtocolError(resp.error, resp.error_code))\n                } else if (resp.data !== undefined ||\n                           resp.token !== undefined) {\n                  try {\n                    reqSubscriber.next(resp)\n                  } catch (e) { }\n                }\n                if (resp.state === 'synced') {\n                  // Create a little dummy object for sync notifications\n                  reqSubscriber.next({\n                    type: 'state',\n                    state: 'synced',\n                  })\n                } else if (resp.state === 'complete') {\n                  reqSubscriber.complete()\n                }\n              },\n              err => reqSubscriber.error(err),\n              () => reqSubscriber.complete()\n            )\n      return () => {\n        // Unsubscribe if necessary\n        unsubscriptions.next(unsubscribeRequest)\n        decrementActive()\n        unsubscribeFilter.unsubscribe()\n      }\n    })\n  }\n}\n\nmodule.exports = HorizonSocket\n"]}