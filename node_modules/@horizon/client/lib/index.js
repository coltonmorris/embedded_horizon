'use strict';

var _Observable = require('rxjs/Observable');

require('rxjs/add/observable/of');

require('rxjs/add/observable/from');

require('rxjs/add/operator/catch');

require('rxjs/add/operator/concatMap');

require('rxjs/add/operator/map');

require('rxjs/add/operator/filter');

require('rxjs/add/operator/defaultIfEmpty');

var _require = require('./ast.js');

// Extra operators not used, but useful to Horizon end-users


var Collection = _require.Collection;
var UserDataTerm = _require.UserDataTerm;

var HorizonSocket = require('./socket.js');

var _require2 = require('./logging.js');

var log = _require2.log;
var logError = _require2.logError;
var enableLogging = _require2.enableLogging;

var _require3 = require('./auth');

var authEndpoint = _require3.authEndpoint;
var TokenStorage = _require3.TokenStorage;
var clearAuthTokens = _require3.clearAuthTokens;


var defaultHost = typeof window !== 'undefined' && window.location && '' + window.location.host || 'localhost:8181';
var defaultSecure = typeof window !== 'undefined' && window.location && window.location.protocol === 'https:' || false;

function Horizon() {
  var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  var _ref$host = _ref.host;
  var host = _ref$host === undefined ? defaultHost : _ref$host;
  var _ref$secure = _ref.secure;
  var secure = _ref$secure === undefined ? defaultSecure : _ref$secure;
  var _ref$path = _ref.path;
  var path = _ref$path === undefined ? 'horizon' : _ref$path;
  var _ref$lazyWrites = _ref.lazyWrites;
  var lazyWrites = _ref$lazyWrites === undefined ? false : _ref$lazyWrites;
  var _ref$authType = _ref.authType;
  var authType = _ref$authType === undefined ? 'unauthenticated' : _ref$authType;

  // If we're in a redirection from OAuth, store the auth token for
  // this user in localStorage.

  var tokenStorage = new TokenStorage({ authType: authType, path: path });
  tokenStorage.setAuthFromQueryParams();

  var socket = new HorizonSocket(host, secure, path, tokenStorage.handshake.bind(tokenStorage));

  // Store whatever token we get back from the server when we get a
  // handshake response
  socket.handshake.subscribe({
    next: function next(handshake) {
      if (authType !== 'unauthenticated') {
        tokenStorage.set(handshake.token);
      }
    },
    error: function error(err) {
      if (/JsonWebTokenError|TokenExpiredError/.test(err.message)) {
        console.error('Horizon: clearing token storage since auth failed');
        tokenStorage.remove();
      }
    }
  });

  // This is the object returned by the Horizon function. It's a
  // function so we can construct a collection simply by calling it
  // like horizon('my_collection')
  function horizon(name) {
    return new Collection(sendRequest, name, lazyWrites);
  }

  horizon.currentUser = function () {
    return new UserDataTerm(horizon, socket.handshake, socket);
  };

  horizon.disconnect = function () {
    socket.complete();
  };

  // Dummy subscription to force it to connect to the
  // server. Optionally provide an error handling function if the
  // socket experiences an error.
  // Note: Users of the Observable interface shouldn't need this
  horizon.connect = function () {
    var onError = arguments.length <= 0 || arguments[0] === undefined ? function (err) {
      console.error('Received an error: ' + err);
    } : arguments[0];

    socket.subscribe(function () {}, onError);
  };

  // Either subscribe to status updates, or return an observable with
  // the current status and all subsequent status changes.
  horizon.status = subscribeOrObservable(socket.status);

  // Convenience method for finding out when disconnected
  horizon.onDisconnected = subscribeOrObservable(socket.status.filter(function (x) {
    return x.type === 'disconnected';
  }));

  // Convenience method for finding out when ready
  horizon.onReady = subscribeOrObservable(socket.status.filter(function (x) {
    return x.type === 'ready';
  }));

  // Convenience method for finding out when an error occurs
  horizon.onSocketError = subscribeOrObservable(socket.status.filter(function (x) {
    return x.type === 'error';
  }));

  horizon.utensils = {
    sendRequest: sendRequest,
    tokenStorage: tokenStorage,
    handshake: socket.handshake
  };
  Object.freeze(horizon.utensils);

  horizon._authMethods = null;
  horizon._horizonPath = path;
  horizon.authEndpoint = authEndpoint;
  horizon.hasAuthToken = tokenStorage.hasAuthToken.bind(tokenStorage);

  return horizon;

  // Sends a horizon protocol request to the server, and pulls the data
  // portion of the response out.
  function sendRequest(type, options) {
    // Both remove and removeAll use the type 'remove' in the protocol
    var normalizedType = type === 'removeAll' ? 'remove' : type;
    return socket.makeRequest({ type: normalizedType, options: options }) // send the raw request
    .concatMap(function (resp) {
      // unroll arrays being returned
      if (resp.data) {
        return _Observable.Observable.from(resp.data);
      } else {
        // Still need to emit a document even if we have no new data
        return _Observable.Observable.from([{ state: resp.state, type: resp.type }]);
      }
    }).catch(function (e) {
      return _Observable.Observable.create(function (subscriber) {
        subscriber.error(e);
      });
    }); // on error, strip error message
  }
}

function subscribeOrObservable(observable) {
  return function () {
    if (arguments.length > 0) {
      return observable.subscribe.apply(observable, arguments);
    } else {
      return observable;
    }
  };
}

Horizon.log = log;
Horizon.logError = logError;
Horizon.enableLogging = enableLogging;
Horizon.Socket = HorizonSocket;
Horizon.clearAuthTokens = clearAuthTokens;

module.exports = Horizon;
//# sourceMappingURL=index.js.map