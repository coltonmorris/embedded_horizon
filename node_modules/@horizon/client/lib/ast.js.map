{"version":3,"sources":["../src/ast.js"],"names":[],"mappings":"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","file":"ast.js","sourcesContent":["import { Observable } from 'rxjs/Observable'\nimport 'rxjs/add/observable/empty'\n\nimport 'rxjs/add/operator/publishReplay'\nimport 'rxjs/add/operator/scan'\nimport 'rxjs/add/operator/filter'\nimport 'rxjs/add/operator/map'\nimport 'rxjs/add/operator/toArray'\nimport 'rxjs/add/operator/take'\n\nimport snakeCase from 'snake-case'\n\nimport checkArgs from './util/check-args'\nimport validIndexValue from './util/valid-index-value.js'\nimport { serialize } from './serialization.js'\n\n\n/**\n @this TermBase\n\n Validation check to throw an exception if a method is chained onto a\n query that already has it. It belongs to TermBase, but we don't want\n to pollute the objects with it (since it isn't useful to api users),\n so it's dynamically bound with :: inside methods that use it.\n*/\nfunction checkIfLegalToChain(key) {\n  if (this._legalMethods.indexOf(key) === -1) {\n    throw new Error(`${key} cannot be called on the current query`)\n  }\n  if (snakeCase(key) in this._query) {\n    throw new Error(`${key} has already been called on this query`)\n  }\n}\n\n// Abstract base class for terms\nexport class TermBase {\n  constructor(sendRequest, query, legalMethods) {\n    this._sendRequest = sendRequest\n    this._query = query\n    this._legalMethods = legalMethods\n  }\n  // Returns a sequence of the result set. Every time it changes the\n  // updated sequence will be emitted. If raw change objects are\n  // needed, pass the option 'rawChanges: true'. An observable is\n  // returned which will lazily emit the query when it is subscribed\n  // to\n  watch({ rawChanges = false } = {}) {\n    const raw = this._sendRequest('subscribe', this._query)\n    if (rawChanges) {\n      return raw\n    } else {\n      return makePresentable(raw, this._query)\n    }\n  }\n  // Grab a snapshot of the current query (non-changefeed). Emits an\n  // array with all results. An observable is returned which will\n  // lazily emit the query when subscribed to\n  fetch() {\n    const raw = this._sendRequest('query', this._query).map(val => {\n      delete val.$hz_v$\n      return val\n    })\n    if (this._query.find) {\n      return raw\n    } else {\n      return raw.toArray()\n    }\n  }\n  findAll(...fieldValues) {\n    this::checkIfLegalToChain('findAll')\n    checkArgs('findAll', arguments, { maxArgs: 100 })\n    return new FindAll(this._sendRequest, this._query, fieldValues)\n  }\n  find(idOrObject) {\n    this::checkIfLegalToChain('find')\n    checkArgs('find', arguments)\n    return new Find(this._sendRequest, this._query, idOrObject)\n  }\n  order(fields, direction = 'ascending') {\n    this::checkIfLegalToChain('order')\n    checkArgs('order', arguments, { minArgs: 1, maxArgs: 2 })\n    return new Order(this._sendRequest, this._query, fields, direction)\n  }\n  above(aboveSpec, bound = 'closed') {\n    this::checkIfLegalToChain('above')\n    checkArgs('above', arguments, { minArgs: 1, maxArgs: 2 })\n    return new Above(this._sendRequest, this._query, aboveSpec, bound)\n  }\n  below(belowSpec, bound = 'open') {\n    this::checkIfLegalToChain('below')\n    checkArgs('below', arguments, { minArgs: 1, maxArgs: 2 })\n    return new Below(this._sendRequest, this._query, belowSpec, bound)\n  }\n  limit(size) {\n    this::checkIfLegalToChain('limit')\n    checkArgs('limit', arguments)\n    return new Limit(this._sendRequest, this._query, size)\n  }\n}\n\n// Turn a raw observable of server responses into user-presentable events\n//\n// `observable` is the base observable with full responses coming from\n//              the HorizonSocket\n// `query` is the value of `options` in the request\nfunction makePresentable(observable, query) {\n  // Whether the entire data structure is in each change\n  const pointQuery = Boolean(query.find)\n\n  if (pointQuery) {\n    let hasEmitted = false\n    const seedVal = null\n    // Simplest case: just pass through new_val\n    return observable\n      .filter(change => !hasEmitted || change.type !== 'state')\n      .scan((previous, change) => {\n        hasEmitted = true\n        if (change.new_val != null) {\n          delete change.new_val.$hz_v$\n        }\n        if (change.old_val != null) {\n          delete change.old_val.$hz_v$\n        }\n        if (change.state === 'synced') {\n          return previous\n        } else {\n          return change.new_val\n        }\n      }, seedVal)\n  } else {\n    const seedVal = { emitted: false, val: [] }\n    return observable\n      .scan((state, change) => {\n        if (change.new_val != null) {\n          delete change.new_val.$hz_v$\n        }\n        if (change.old_val != null) {\n          delete change.old_val.$hz_v$\n        }\n        if (change.state === 'synced') {\n          state.emitted = true\n        }\n        state.val = applyChange(state.val.slice(), change)\n        return state\n      }, seedVal)\n      .filter(state => state.emitted)\n      .map(x => x.val)\n  }\n}\n\nexport function applyChange(arr, change) {\n  switch (change.type) {\n  case 'remove':\n  case 'uninitial': {\n    // Remove old values from the array\n    if (change.old_offset != null) {\n      arr.splice(change.old_offset, 1)\n    } else {\n      const index = arr.findIndex(x => x.id === change.old_val.id)\n      arr.splice(index, 1)\n    }\n    break\n  }\n  case 'add':\n  case 'initial': {\n    // Add new values to the array\n    if (change.new_offset != null) {\n      // If we have an offset, put it in the correct location\n      arr.splice(change.new_offset, 0, change.new_val)\n    } else {\n      // otherwise for unordered results, push it on the end\n      arr.push(change.new_val)\n    }\n    break\n  }\n  case 'change': {\n    // Modify in place if a change is happening\n    if (change.old_offset != null) {\n      // Remove the old document from the results\n      arr.splice(change.old_offset, 1)\n    }\n    if (change.new_offset != null) {\n      // Splice in the new val if we have an offset\n      arr.splice(change.new_offset, 0, change.new_val)\n    } else {\n      // If we don't have an offset, find the old val and\n      // replace it with the new val\n      const index = arr.findIndex(x => x.id === change.old_val.id)\n      arr[index] = change.new_val\n    }\n    break\n  }\n  case 'state': {\n    // This gets hit if we have not emitted yet, and should\n    // result in an empty array being output.\n    break\n  }\n  default:\n    throw new Error(\n      `unrecognized 'type' field from server ${JSON.stringify(change)}`)\n  }\n  return arr\n}\n\n/** @this Collection\n Implements writeOps for the Collection class\n*/\nfunction writeOp(name, args, documents) {\n  checkArgs(name, args)\n  let isBatch = true\n  let wrappedDocs = documents\n  if (!Array.isArray(documents)) {\n    // Wrap in an array if we need to\n    wrappedDocs = [ documents ]\n    isBatch = false\n  } else if (documents.length === 0) {\n    // Don't bother sending no-ops to the server\n    return Observable.empty()\n  }\n  const options = Object.assign(\n    {}, this._query, { data: serialize(wrappedDocs) })\n  let observable = this._sendRequest(name, options)\n  if (isBatch) {\n    // If this is a batch writeOp, each document may succeed or fail\n    // individually.\n    observable = observable.map(resp => resp.error? new Error(resp.error) : resp)\n  } else {\n    // If this is a single writeOp, the entire operation should fail\n    // if any fails.\n    let _prevOb = observable\n    observable = Observable.create(subscriber => {\n      _prevOb.subscribe({\n        next(resp) {\n          if (resp.error) {\n            // TODO: handle error ids when we get them\n            subscriber.error(new Error(resp.error))\n          } else {\n            subscriber.next(resp)\n          }\n        },\n        error(err) { subscriber.error(err) },\n        complete() { subscriber.complete() },\n      })\n    })\n  }\n  if (!this._lazyWrites) {\n    // Need to buffer response since this becomes a hot observable and\n    // when we subscribe matters\n    observable = observable.publishReplay().refCount()\n    observable.subscribe()\n  }\n  return observable\n}\n\nexport class Collection extends TermBase {\n  constructor(sendRequest, collectionName, lazyWrites) {\n    const query = { collection: collectionName }\n    const legalMethods = [\n      'find', 'findAll', 'justInitial', 'order', 'above', 'below', 'limit' ]\n    super(sendRequest, query, legalMethods)\n    this._lazyWrites = lazyWrites\n  }\n  store(documents) {\n    return this::writeOp('store', arguments, documents)\n  }\n  upsert(documents) {\n    return this::writeOp('upsert', arguments, documents)\n  }\n  insert(documents) {\n    return this::writeOp('insert', arguments, documents)\n  }\n  replace(documents) {\n    return this::writeOp('replace', arguments, documents)\n  }\n  update(documents) {\n    return this::writeOp('update', arguments, documents)\n  }\n  remove(documentOrId) {\n    const wrapped = validIndexValue(documentOrId) ?\n          { id: documentOrId } : documentOrId\n    return this::writeOp('remove', arguments, wrapped)\n  }\n  removeAll(documentsOrIds) {\n    if (!Array.isArray(documentsOrIds)) {\n      throw new Error('removeAll takes an array as an argument')\n    }\n    const wrapped = documentsOrIds.map(item => {\n      if (validIndexValue(item)) {\n        return { id: item }\n      } else {\n        return item\n      }\n    })\n    return this::writeOp('removeAll', arguments, wrapped)\n  }\n}\n\nexport class Find extends TermBase {\n  constructor(sendRequest, previousQuery, idOrObject) {\n    const findObject = validIndexValue(idOrObject) ?\n          { id: idOrObject } : idOrObject\n    const query = Object.assign({}, previousQuery, { find: findObject })\n    super(sendRequest, query, [])\n  }\n}\n\nexport class FindAll extends TermBase {\n  constructor(sendRequest, previousQuery, fieldValues) {\n    const wrappedFields = fieldValues\n          .map(item => validIndexValue(item) ? { id: item } : item)\n    const options = { find_all: wrappedFields }\n    const findAllQuery = Object.assign({}, previousQuery, options)\n    let legalMethods\n    if (wrappedFields.length === 1) {\n      legalMethods = [ 'order', 'above', 'below', 'limit' ]\n    } else {\n      // The vararg version of findAll cannot have anything chained to it\n      legalMethods = []\n    }\n    super(sendRequest, findAllQuery, legalMethods)\n  }\n}\n\nexport class Above extends TermBase {\n  constructor(sendRequest, previousQuery, aboveSpec, bound) {\n    const option = { above: [ aboveSpec, bound ] }\n    const query = Object.assign({}, previousQuery, option)\n    const legalMethods = [ 'findAll', 'order', 'below', 'limit' ]\n    super(sendRequest, query, legalMethods)\n  }\n}\n\nexport class Below extends TermBase {\n  constructor(sendRequest, previousQuery, belowSpec, bound) {\n    const options = { below: [ belowSpec, bound ] }\n    const query = Object.assign({}, previousQuery, options)\n    const legalMethods = [ 'findAll', 'order', 'above', 'limit' ]\n    super(sendRequest, query, legalMethods)\n  }\n}\n\nexport class Order extends TermBase {\n  constructor(sendRequest, previousQuery, fields, direction) {\n    const wrappedFields = Array.isArray(fields) ? fields : [ fields ]\n    const options = { order: [ wrappedFields, direction ] }\n    const query = Object.assign({}, previousQuery, options)\n    const legalMethods = [ 'findAll', 'above', 'below', 'limit' ]\n    super(sendRequest, query, legalMethods)\n  }\n}\n\nexport class Limit extends TermBase {\n  constructor(sendRequest, previousQuery, size) {\n    const query = Object.assign({}, previousQuery, { limit: size })\n    // Nothing is legal to chain after .limit\n    super(sendRequest, query, [])\n  }\n}\n\n\nexport class UserDataTerm {\n  constructor(hz, handshake, socket) {\n    this._hz = hz\n    this._before = Observable.merge(\n      socket.take(0), // just need to force connection\n      handshake // guarantee we get handshake even if we're already\n                // connected\n    )\n  }\n\n  _query(userId) {\n    return this._hz('users').find(userId)\n  }\n\n  fetch() {\n    return this._before.concatMap(handshake => {\n      if (handshake.id === null) {\n        return Observable.of({})\n      } else {\n        return this._query(handshake.id).fetch()\n      }\n    })\n  }\n\n  watch(...args) {\n    return this._before.concatMap(handshake => {\n      if (handshake.id === null) {\n        return Observable.of({})\n      } else {\n        return this._query(handshake.id).watch(...args)\n      }\n    })\n  }\n}\n"]}